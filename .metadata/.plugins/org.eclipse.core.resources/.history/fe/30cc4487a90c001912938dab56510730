import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.PriorityQueue;
import java.util.Queue;
import java.util.Scanner;


public class Main {
	
	static int V, E, K;
	static int[] dist;	
	static boolean[] visited;
	static ArrayList<Pair>[] adj;
	
	public static void main(String[] args) throws FileNotFoundException {
		System.setIn(new FileInputStream("res/input.txt"));
		
		Scanner sc = new Scanner(System.in);
		
		V = sc.nextInt();
		E = sc.nextInt();
		K = sc.nextInt();
		
		dist = new int[V+1];
		visited = new boolean[V+1];
		adj = new ArrayList[V+1];
		for(int i=0;i<=V;i++) {
			adj[i] = new ArrayList<>();
		}
		
		
		Arrays.fill(dist, Integer.MAX_VALUE);
		Arrays.fill(visited, false);
		
		for (int i=0;i<E;i++) {
			int u, v, w;
			u = sc.nextInt();
			v = sc.nextInt();
			w = sc.nextInt();
			adj[u].add(new Pair(v, w));
		}
		
		dijkstra(K);
		
		for(int i=1;i<=V;i++) {
			if (i==K) {
				System.out.println(0);	
			} else if(dist[i] == Integer.MAX_VALUE) {
				System.out.println("INF");
			} else {
				System.out.println(dist[i]);
			}
		}
	}
	
	static class Pair implements Comparable<Pair> {
		int next;
		int weitght;
		public Pair(int next, int weitght) {
			super();
			this.next = next;
			this.weitght = weitght;
		}
		
		@Override
		public int compareTo(Pair o) {
			// TODO Auto-generated method stub
			return this.weitght - o.weitght;
		}
	}
	
	static void dijkstra(int start) {
		PriorityQueue<Integer> q = new PriorityQueue<Integer>();
        // 시작점 설정해주고 시작점 - 시작점 거리는 0이다.
        q.add(start);
        dist[start] = 0;
        while (!q.isEmpty()) {
            // 다음에 방문할 vertex 설정
            int current = q.poll();
            // 방문했기 떄문에 true, INF는 아니다.
            visited[current] = true;
 
            for (int i = 0; i < adj[current].size(); i++) {
                // 현재 vertex에서 다음 vertex를 차근차근 비교해서 우선순위 큐에 넣어야한다.
                int next = adj[current].get(i).next; // 다음 vertex
                int value = adj[current].get(i).weitght; // 현재 - 다음 간 edge값
                
                if(visited[current])continue;
 
                // 이전에 있던 값이 더 크다면 굳이 다시 방문할 필요가 없다. 이미 그 전이 더 최단 경로이기 때문에
                if (dist[next] > dist[current] + value) {
                	dist[next] = Math.min(dist[next], value + dist[current]);
                    q.add(next);
                }
            }
        }
		
	}
}
